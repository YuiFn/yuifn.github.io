<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code |&gt; Functional |&gt; Fun</title>
    <link>https://yuifn.github.io/</link>
    <description>Recent content on Code |&gt; Functional |&gt; Fun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 27 Nov 2018 21:18:47 +0800</lastBuildDate>
    
	<atom:link href="https://yuifn.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust Phantom Type</title>
      <link>https://yuifn.github.io/2018/11/rust-phantom-type/</link>
      <pubDate>Tue, 27 Nov 2018 21:18:47 +0800</pubDate>
      
      <guid>https://yuifn.github.io/2018/11/rust-phantom-type/</guid>
      <description>在具有高级类型系统的语言里面,有一种类型叫Phantom Type,Rust如此强大的类型系统当然也不再话下.
Phantom Type或叫幽灵类型,你或许想起了Java的PhantomReference,嗯&amp;hellip;或许没有,但不管怎么样以Phantom为名的都具有一个共性: 它们都是对其所拥有的东东进行&amp;rdquo;行为标记&amp;rdquo;在特定的上下文环境执行一些更严格的逻辑或者约束.对于Java可以通过PhantomReference跟踪 GC或者最后进行一些清理的工作,对于Rust那就更多了后边会讲到.
由于Rust本身一些喜闻乐见的特性(LifeTime,Drop Checker)Phantom Type被赋予了更多的功能(自己挖的抗,含泪也要填完).在Rust中 Phantom Type对应的实现为PhantomData这是一个Zero-sized type.对于编译后的代码来说，完全没有任何的副作用. 这也是zero-cost abstractions的一种体现. 下边列举下它具体的使用场景:
Compile time type check 编译期的静态类型检测是Phantom Type的一种常见用法,在一些其他语言里面也叫类型标记法,这里它标记的是它所拥有的类型并对这个类型进行约束 这里列举一个常见的单位运算的例子.在支付系统中经常会遇到不同单位的价格进行计算的问题一不留神就会出错
use std::marker::PhantomData; use std::ops::Add; type USD = f64; type CNY = f64; #[derive(Debug)] struct Money&amp;lt;Num&amp;gt;(Num); impl&amp;lt;Num: Add&amp;lt;Output = Num&amp;gt;&amp;gt; Add for Money&amp;lt;Num&amp;gt; { type Output = Money&amp;lt;Num&amp;gt;; fn add(self, rhs: Money&amp;lt;Num&amp;gt;) -&amp;gt; Money&amp;lt;Num&amp;gt; { Length(self.0 + rhs.0) } } fn main() { let usd = Money(5.0 as USD); let cny = Money(5.</description>
    </item>
    
    <item>
      <title>Hello</title>
      <link>https://yuifn.github.io/2018/11/hello/</link>
      <pubDate>Tue, 20 Nov 2018 13:36:58 +0800</pubDate>
      
      <guid>https://yuifn.github.io/2018/11/hello/</guid>
      <description>开篇Higher-Order-Function &amp;ndash; Map 许久不写了,这次重新捡起.作为开篇没有太多内容要说,以Higher-Order-Function中的map函数来做简单的说明.
map是一个接受一个函数并把这个函数作为一个functor应用于每一个元素的函数.如下图 下边看看各种语言的一个大概实现,代码的意思是对一个[1,5]的列表,对其每个元素➕1
Scala val list = 1 to 5; list.map(_ + 1).toList();  Ocaml let plus = ( + );; (* 这里是为了对此,可以使用List.range 1 6;; *) let list = List.init 5 ~f:(plus 1); list |&amp;gt; List.map ~f: plus |&amp;gt; List.map ~f: (fun fn -&amp;gt; fn 1);;  Rust fn main(){ // 这里指定下类型 let list: Vec&amp;lt;_&amp;gt; = (1..5).map(|x| x + 1).collect(); }  Elixir 1..5 |&amp;gt; Enum.map(&amp;amp;(&amp;amp;1 + 1))  Dart main(List&amp;lt;String&amp;gt; args) { final list = [1, 2, 3, 4, 5]; list.</description>
    </item>
    
  </channel>
</rss>