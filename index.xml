<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code |&gt; Functional |&gt; Fun</title>
    <link>https://yuifn.github.io/</link>
    <description>Recent content on Code |&gt; Functional |&gt; Fun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Dec 2018 12:23:15 +0800</lastBuildDate>
    
	<atom:link href="https://yuifn.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Different Profiles in Flutter apps</title>
      <link>https://yuifn.github.io/2018/12/different-profiles-in-flutter-apps/</link>
      <pubDate>Mon, 03 Dec 2018 12:23:15 +0800</pubDate>
      
      <guid>https://yuifn.github.io/2018/12/different-profiles-in-flutter-apps/</guid>
      <description>在日常的开发中需要根据不同的Profile/env来加载对应的配置信息，比如dev，qa， prod等。Flutter怎么实现这个功能呢？ 浏览下文档无果，最后在其examples/catalog的例子中找到了一个可行的方法
flutter run lib/animated_list.dart flutter run lib/app_bar_bottom.dart flutter run lib/basic_app_bar.dart ...  Flutter生成的main.dart是默认的APP入口文件但可以通过命令修改为其他文件如上，所以只要按照不同的Profile创建不同的main的文件即可，如 main_dev.dart对应着的开发环境。用一个例子说明下
01 - 生成一个默认的项目 flutter create profiles # 在lib中的结构如下: lib └── main.dart  02 - 分离main.dart中的类为独立的文件 ├── main.dart ├── app.dart └── my_home_page.dart  03 - 添加配置信息 添加一个新类用于存储需要的配置信息
/// config/app_config.dart import &#39;package:meta/meta.dart&#39;; class AppConfig { final String appName; final String apiBaseUrl; AppConfig({@required this.appName, @required this.apiBaseUrl}): assert(appName!=null), assert(apiBaseUrl!=null); }  那怎么在不同的Widget之间传递配置信息呢？一个直观的做法就是直接创建在不同的环境中创建一个全局的对象，然后直接访问比如
/// main_dev.dart main(){ final dev = AppConfig( appName: &amp;quot;app - dev&amp;quot;, apiBaseUrl: &amp;quot;https://dev.</description>
    </item>
    
    <item>
      <title>Rust Phantom Type</title>
      <link>https://yuifn.github.io/2018/11/rust-phantom-type/</link>
      <pubDate>Tue, 27 Nov 2018 21:18:47 +0800</pubDate>
      
      <guid>https://yuifn.github.io/2018/11/rust-phantom-type/</guid>
      <description>在具有高级类型系统的语言里面,有一种类型叫Phantom Type,Rust如此强大的类型系统当然也不再话下.
Phantom Type或叫幽灵类型,你或许想起了Java的PhantomReference,嗯&amp;hellip;或许没有,但不管怎么样以Phantom为名的都具有一个共性: 它们都是对其所拥有的东东进行&amp;rdquo;行为标记&amp;rdquo;在特定的上下文环境执行一些更严格的逻辑或者约束.对于Java可以通过PhantomReference跟踪 GC或者最后进行一些清理的工作,对于Rust那就更多了后边会讲到.
由于Rust本身一些喜闻乐见的特性(LifeTime,Drop Checker)Phantom Type被赋予了更多的功能(自己挖的抗,含泪也要填完).在Rust中 Phantom Type对应的实现为PhantomData这是一个Zero-sized type.对于编译后的代码来说，完全没有任何的副作用. 这也是zero-cost abstractions的一种体现. 下边列举下它具体的使用场景:
Compile time type check 编译期的静态类型检测是Phantom Type的一种常见用法,在一些其他语言里面也叫类型标记法,这里它标记的是它所拥有的类型并对这个类型进行约束 这里列举一个常见的单位运算的例子.在支付系统中经常会遇到不同单位的价格进行计算的问题一不留神就会出错
use std::marker::PhantomData; use std::ops::Add; type USD = f64; type CNY = f64; #[derive(Debug)] struct Money&amp;lt;Num&amp;gt;(Num); impl&amp;lt;Num: Add&amp;lt;Output = Num&amp;gt;&amp;gt; Add for Money&amp;lt;Num&amp;gt; { type Output = Money&amp;lt;Num&amp;gt;; fn add(self, rhs: Money&amp;lt;Num&amp;gt;) -&amp;gt; Money&amp;lt;Num&amp;gt; { Length(self.0 + rhs.0) } } fn main() { let usd = Money(5.0 as USD); let cny = Money(5.</description>
    </item>
    
    <item>
      <title>Hello</title>
      <link>https://yuifn.github.io/2018/11/hello/</link>
      <pubDate>Tue, 20 Nov 2018 13:36:58 +0800</pubDate>
      
      <guid>https://yuifn.github.io/2018/11/hello/</guid>
      <description>开篇Higher-Order-Function &amp;ndash; Map 许久不写了,这次重新捡起.作为开篇没有太多内容要说,以Higher-Order-Function中的map函数来做简单的说明.
map是一个接受一个函数并把这个函数作为一个functor应用于每一个元素的函数.如下图 下边看看各种语言的一个大概实现,代码的意思是对一个[1,5]的列表,对其每个元素➕1
Scala val list = 1 to 5; list.map(_ + 1).toList();  Ocaml let plus = ( + );; (* 这里是为了对此,可以使用List.range 1 6;; *) let list = List.init 5 ~f:(plus 1); list |&amp;gt; List.map ~f: plus |&amp;gt; List.map ~f: (fun fn -&amp;gt; fn 1);;  Rust fn main(){ // 这里指定下类型 let list: Vec&amp;lt;_&amp;gt; = (1..5).map(|x| x + 1).collect(); }  Elixir 1..5 |&amp;gt; Enum.map(&amp;amp;(&amp;amp;1 + 1))  Dart main(List&amp;lt;String&amp;gt; args) { final list = [1, 2, 3, 4, 5]; list.</description>
    </item>
    
  </channel>
</rss>